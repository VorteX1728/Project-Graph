import pygame
import sys
import random
from collections import deque
import heapq

# DFS со стеком для создания лабиринта
def labyrynth(x, y):
    stack = [(x, y)]
    matrix[x][y] = white
    while stack:
        cx, cy = stack[-1]
        directions = [(0, 2), (2, 0), (0, -2), (-2, 0)]
        random.shuffle(directions)
        for dx, dy in directions:
            nx, ny = cx + dx, cy + dy
            if 1 <= nx < r - 1 and 1 <= ny < c - 1 and matrix[nx][ny] == gray:
                matrix[nx][ny] = white
                matrix[cx + dx // 2][cy + dy // 2] = white
                stack.append((nx, ny))
                break
        else:
            stack.pop()

# BFS для проверки выхода
def exit_possible(startx, starty, exitx, exity):
    visited = [[False] * c for i in range(r)]
    queue = deque([(startx, starty)])
    visited[startx][starty] = True

    while queue:
        x, y = queue.popleft()
        if x == exitx and y == exity:
            return True
        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < r and 0 <= ny < c and not visited[nx][ny] and matrix[nx][ny] == white:
                visited[nx][ny] = True
                queue.append((nx, ny))
    return False

# Дейкстра для врага
def deikstra(start, goal, grid):
    queue = []
    heapq.heappush(queue, (0, start))
    came_from = {}
    cost_so_far = {start: 0}

    while queue:
        current = heapq.heappop(queue)[1]

        if current == goal:
            path = []
            node = goal
            while node != start:
                path.append(node)
                node = came_from[node]
            path.append(start)
            path.reverse()
            return path

        x, y = current
        neighbors = []
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < r and 0 <= ny < c and grid[nx][ny] != gray:
                neighbors.append((nx, ny))

        for neighbor in neighbors:
            new_cost = cost_so_far[current] + 1
            if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                cost_so_far[neighbor] = new_cost
                priority = new_cost
                heapq.heappush(queue, (priority, neighbor))
                came_from[neighbor] = current

    return []

def newRoom(startx, starty, size, coinsnum, spikesnum, enemiesnum):
    global playerx, playery, matrix, coins, spikes, enemies, coins_count, HP_count, exitx, exity
    playerx, playery = startx, starty
    matrix = [[gray for i in range(c)] for j in range(r)]
    matrix[startx][starty] = white
    labyrynth(startx, starty)

    for i in range(size // 2):
        cycx, cycy = random.randint(2, c - 3), random.randint(2, r - 3)
        matrix[cycx][cycy] = white

    exitx, exity = None, None

    exits = []
    for i in range(1, r - 1):
        if matrix[i][c - 2] == white:
            exits.append(i)
    if exits:
        exitx = random.choice(exits)
    else:
        exitx = random.randint(1, r - 2)
        i = 2
    exity = c - 1
    if exitx is not None and exity is not None:
        matrix[exitx][exity] = white
        matrix[exitx][exity - 1] = white

    coins = []
    for i in range(coinsnum):
        while True:
            coinx, coiny = random.randint(1, r - 2), random.randint(1, c - 2)
            if matrix[coinx][coiny] == white and [coinx, coiny] not in coins:
                coins.append([coinx, coiny])
                break

    spikes = []
    for i in range(spikesnum):
        while True:
            spikex, spikey = random.randint(1, r - 2), random.randint(1, c - 2)
            if matrix[spikex][spikey] == white and [spikex, spikey] not in spikes:
                spikes.append([spikex, spikey])
                break

    enemies = []
    for i in range(enemiesnum):
        enemyx, enemyy = random.randint(1, r - 2), random.randint(1, c - 2)
        while matrix[enemyx][enemyy] != white:
            enemyx, enemyy = random.randint(1, r - 2), random.randint(1, c - 2)
        enemies.append([enemyx, enemyy, [], count])

pygame.init()

divisors = [10, 14, 20, 25, 28, 35, 50, 70, 100]
div = 0
width, height = 700, 700
r = divisors[div]
c = r
size = width // c
coinsnum = 0
spikesnum = 0
enemiesnum = 0
coins_count = 0
HP_count = 5
on_spike = False
on_enemie = False
speed = 7
count = 0
roomnum = 1

white = (255, 255, 255)
black = (0, 0, 0)
gray = (125, 125, 125)
blue = (0, 0, 255)
red = (255, 0, 0)
yellow = (255, 215, 0)

screen = pygame.display.set_mode((width + 300, height))
pygame.display.set_caption("Лабиринт")
clock = pygame.time.Clock()

newRoom(1, 0, size, coinsnum, spikesnum, enemiesnum)

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_UP and matrix[playerx - 1][playery] == white:
                playerx -= 1
            elif event.key == pygame.K_DOWN and matrix[playerx + 1][playery] == white:
                playerx += 1
            elif event.key == pygame.K_LEFT and matrix[playerx][playery - 1] == white:
                playery -= 1
            elif event.key == pygame.K_RIGHT and matrix[playerx][playery + 1] == white:
                playery += 1
            if event.key == pygame.K_ESCAPE:
                running = False

    if [playerx, playery] in coins:
        coins.remove([playerx, playery])
        coins_count += 1

    if [playerx, playery] in spikes:
        if not on_spike:
            HP_count -= 1
            on_spike = True
    else:
        on_spike = False

    for i in range(enemiesnum):
        enemyx, enemyy, path, count = enemies[i]
        count += 1
        if count >= speed:
            if not path:
                path = deikstra((enemyx, enemyy), (playerx, playery), matrix)
            else:
                new = path.pop(0)
                enemyx, enemyy = new[0], new[1]
            count = 0
        enemies[i] = [enemyx, enemyy, path, count]

        if playerx == enemyx and playery == enemyy:
            if not on_enemie:
                HP_count -= 1
                on_enemie = True
        else:
            on_enemie = False

    if playerx == exitx and playery == exity:
        r = divisors[div]
        c = r
        size = width // c
        if roomnum in [3, 7, 12, 20, 27]:
            div += 1
        if roomnum % 2 == 0:
            coinsnum += 1
        if roomnum % 3 == 0 and roomnum <= 15:
            spikesnum += 1
        if roomnum % 4 == 0 and roomnum <= 12:
            enemiesnum += 1

        newRoom(1, 0, size, coinsnum, spikesnum, enemiesnum)
        roomnum += 1


    screen.fill(gray)

    for row in range(r):
        for col in range(c):
            rect = pygame.Rect(col * size, row * size, size, size)
            pygame.draw.rect(screen, matrix[row][col], rect)
            pygame.draw.rect(screen, black, rect, 1)

    for i in spikes:
        spike = pygame.Rect(i[1] * size, i[0] * size, size, size)
        pygame.draw.rect(screen, red, spike)

    player = pygame.Rect(playery * size, playerx * size, size, size)
    pygame.draw.rect(screen, blue, player)

    for i in coins:
        coin = pygame.Rect(i[1] * size, i[0] * size, size, size)
        pygame.draw.rect(screen, yellow, coin)

    for i in enemies:
        enemy = pygame.Rect(i[1] * size, i[0] * size, size, size)
        pygame.draw.rect(screen, black, enemy)

    pygame.draw.rect(screen, white, (width, 0, 300, height))
    font = pygame.font.Font(None, 36)
    text = font.render(f"Coins: {coins_count}", True, black)
    text2 = font.render(f"HP: {HP_count}", True, black)
    screen.blit(text, (width + 10, 10))
    screen.blit(text2, (width + 10, 50))

    pygame.display.flip()
    clock.tick(30)

pygame.quit()
sys.exit()
